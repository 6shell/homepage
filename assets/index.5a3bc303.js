import{v as t,t as e,a as n,I as r,r as s,c as a,i,p as o,k as c,n as l,m as u,S as d,s as p,R as f,U as h,w as m,V as g}from"./index.63d00a60.js";import"./index.8f5c5dfd.js";import"./color.556e4bcb.js";const y=t=>Object.prototype.hasOwnProperty.call(t,"origin");class v extends Array{findThenRun(t,e){const n=this.findIndex((e=>y(e)&&e.origin===t));return n<0||e(n),this}configure(t,e){return this.findThenRun(t,(n=>{this.splice(n,1,t(e))}))}replace(t,e){return this.findThenRun(t,(t=>{this.splice(t,1,e)}))}remove(t){return this.findThenRun(t,(t=>{this.splice(t,1)}))}headless(){return this.filter(y).forEach((t=>{this.configure(t.origin,{headless:!0})})),this}static create(t){return new v(...t)}}const w=f=>((t,e,n)=>{const r=e;return r.extend=e=>n(((...n)=>e(t(...n),...n))),r})(f,(t=>{const e=n=>{const r=t(n);return r.origin=e,r};return e})((h=>()=>async m=>{const g=((t,r)=>{try{const n=t.get(e);return{getClassName:(s=null==r?void 0:r.className,(t,...e)=>{var n;const r=null!=(n=null==s?void 0:s(t))?n:e;return Array.isArray(r)?r.filter((t=>t)).join(" "):r}),getStyle:t=>(null==r?void 0:r.headless)?"":t(n),themeTool:n}}catch{throw n()}var s})(m,h),y=f(g,h);if(await(async(t,e,n,l)=>{if(await t.wait(r),e.remarkPlugins){const n=e.remarkPlugins(t);t.update(s,(t=>[...t,...n]))}const u=await n();e.commands&&e.commands(u,t).forEach((([e,n])=>{t.get(a).create(e,n)}));if(e.inputRules){const n=e.inputRules(u,t);t.update(i,(t=>[...t,...n]))}if(e.shortcuts){const n=(t,e)=>{var n,r;return null!=(r=null==(n=null==l?void 0:l.keymap)?void 0:n[t])?r:e},r=Object.entries(e.shortcuts).flatMap((([e,[r,s,i]])=>{const o=()=>t.get(a).call(r,i),c=n(e,s);return Array.isArray(c)?c.map((t=>({key:t,runner:o}))):{key:c,runner:o}})).map((t=>[t.key,t.runner]));t.update(o,(t=>t.concat(c(Object.fromEntries(r)))))}if(e.prosePlugins){const n=e.prosePlugins(u,t);t.update(o,(t=>[...t,...n]))}})(m,y,(async()=>{let t={},e={};if(y.schema){const n=y.schema(m);if(n.node){t=n.node;const e=Object.entries(n.node);m.update(l,(t=>[...t,...e]))}if(n.mark){e=n.mark;const t=Object.entries(n.mark);m.update(u,(e=>[...e,...t]))}}await m.wait(d);const n=m.get(p),r=Object.keys(t).map((t=>[t,n.nodes[t]])),s=Object.keys(e).map((t=>[t,n.marks[t]]));return Object.fromEntries([...r,...s])}),h),y.view){const e=y.view(m);m.update(t,(t=>[...t,...Object.entries(e)]))}})),w),b=t=>{if(!t)return!1;if(Array.isArray(t))return!(t.length>1)&&b(t[0]);const e=t.content;return e?b(e):"text"===t.type},j=w((()=>({prosePlugins:(t,e)=>{const n=e.get(p),r=e.get(f),s=e.get(h);return[new m({props:{handlePaste:(t,e)=>{var n,s;const a=null===(s=(n=t.props).editable)||void 0===s?void 0:s.call(n,t.state),{clipboardData:i}=e;if(!a||!i)return!1;const o=i.getData("text/plain");if(i.getData("text/html").length>0)return!1;const c=r(o);if(!c||"string"==typeof c)return!1;const l=t.state.selection.content();return t.dispatch(t.state.tr.replaceSelection(new g(c.content,l.openStart,l.openEnd))),!0},clipboardTextSerializer:t=>{if(b(t.content.toJSON()))return t.content.textBetween(0,t.content.size,"\n\n");const e=n.topNodeType.createAndFill(void 0,t.content);if(!e)return"";return s(e)}}})]}}))),k=v.create([j()]);export{k as clipboard,j as clipboardPlugin};
